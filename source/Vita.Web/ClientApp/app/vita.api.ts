/// <reference path="vita.util.ts" />
/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.13.0 (NJsonSchema v9.10.50.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';
import * as _ from  "./vita.util";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IBankStatementClient {
  login(userIdentifier: string, bankLogin: BankLogin | null): Observable<SearchResponse[] | null>;
  loginFetchAll(userIdentifier: string, bankLogin: BankLogin | null): Observable<SearchResponse[] | null>;
}

@Injectable()
export class BankStatementClient implements IBankStatementClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = _.VitaUtil.getApiUri();
  }

  login(userIdentifier: string, bankLogin: BankLogin | null): Observable<SearchResponse[] | null> {
    let url_ = this.baseUrl + "/BankStatement/login/{userIdentifier}";
    if (userIdentifier === undefined || userIdentifier === null)
      throw new Error("The parameter 'userIdentifier' must be defined.");
    url_ = url_.replace("{userIdentifier}", encodeURIComponent("" + userIdentifier));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(bankLogin);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processLogin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogin(<any>response_);
        } catch (e) {
          return <Observable<SearchResponse[] | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<SearchResponse[] | null>><any>_observableThrow(response_);
    }));
  }

  protected processLogin(response: HttpResponseBase): Observable<SearchResponse[] | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(SearchResponse.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<SearchResponse[] | null>(<any>null);
  }

  loginFetchAll(userIdentifier: string, bankLogin: BankLogin | null): Observable<SearchResponse[] | null> {
    let url_ = this.baseUrl + "/BankStatement/loginfetchall/{userIdentifier}";
    if (userIdentifier === undefined || userIdentifier === null)
      throw new Error("The parameter 'userIdentifier' must be defined.");
    url_ = url_.replace("{userIdentifier}", encodeURIComponent("" + userIdentifier));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(bankLogin);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processLoginFetchAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLoginFetchAll(<any>response_);
        } catch (e) {
          return <Observable<SearchResponse[] | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<SearchResponse[] | null>><any>_observableThrow(response_);
    }));
  }

  protected processLoginFetchAll(response: HttpResponseBase): Observable<SearchResponse[] | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(SearchResponse.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<SearchResponse[] | null>(<any>null);
  }
}

export interface IChargeClient {
  classify(searchPhrase: string): Observable<SearchResponse[] | null>;
  search(searchPhrase: string): Observable<FileResponse | null>;
  get(chargeId: string): Observable<Charge | null>;
  verify(searchResponseId: string, searchPhrase: string | null): Observable<FileResponse | null>;
}

@Injectable()
export class ChargeClient implements IChargeClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = _.VitaUtil.getApiUri();
  }

  classify(searchPhrase: string): Observable<SearchResponse[] | null> {
    let url_ = this.baseUrl + "/Charge/classify/{searchPhrase}";
    if (searchPhrase === undefined || searchPhrase === null)
      throw new Error("The parameter 'searchPhrase' must be defined.");
    url_ = url_.replace("{searchPhrase}", encodeURIComponent("" + searchPhrase));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processClassify(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClassify(<any>response_);
        } catch (e) {
          return <Observable<SearchResponse[] | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<SearchResponse[] | null>><any>_observableThrow(response_);
    }));
  }

  protected processClassify(response: HttpResponseBase): Observable<SearchResponse[] | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(SearchResponse.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<SearchResponse[] | null>(<any>null);
  }

  search(searchPhrase: string): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/Charge/search/{searchPhrase}";
    if (searchPhrase === undefined || searchPhrase === null)
      throw new Error("The parameter 'searchPhrase' must be defined.");
    url_ = url_.replace("{searchPhrase}", encodeURIComponent("" + searchPhrase));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processSearch(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSearch(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processSearch(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  get(chargeId: string): Observable<Charge | null> {
    let url_ = this.baseUrl + "/Charge/{chargeId}";
    if (chargeId === undefined || chargeId === null)
      throw new Error("The parameter 'chargeId' must be defined.");
    url_ = url_.replace("{chargeId}", encodeURIComponent("" + chargeId));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<Charge | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<Charge | null>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<Charge | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 ? Charge.fromJS(resultData200) : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Charge | null>(<any>null);
  }

  verify(searchResponseId: string, searchPhrase: string | null): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/Charge/verify/{searchResponseId}";
    if (searchResponseId === undefined || searchResponseId === null)
      throw new Error("The parameter 'searchResponseId' must be defined.");
    url_ = url_.replace("{searchResponseId}", encodeURIComponent("" + searchResponseId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(searchPhrase);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processVerify(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processVerify(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processVerify(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }
}

export interface IValuesClient {
  getAll(): Observable<string[] | null>;
  post(value: string | null): Observable<void>;
  get(id: number): Observable<string | null>;
  put(id: number, value: string | null): Observable<void>;
  delete(id: number): Observable<void>;
}

@Injectable()
export class ValuesClient implements IValuesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = _.VitaUtil.getApiUri();
  }

  getAll(): Observable<string[] | null> {
    let url_ = this.baseUrl + "/api/Values";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(<any>response_);
        } catch (e) {
          return <Observable<string[] | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<string[] | null>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<string[] | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (resultData200 && resultData200.constructor === Array) {
          result200 = [];
          for (let item of resultData200)
            result200.push(item);
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<string[] | null>(<any>null);
  }

  post(value: string | null): Observable<void> {
    let url_ = this.baseUrl + "/api/Values";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(value);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPost(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPost(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPost(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  get(id: number): Observable<string | null> {
    let url_ = this.baseUrl + "/api/Values/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(<any>response_);
        } catch (e) {
          return <Observable<string | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<string | null>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<string | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<string | null>(<any>null);
  }

  put(id: number, value: string | null): Observable<void> {
    let url_ = this.baseUrl + "/api/Values/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(value);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processPut(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPut(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  delete(id: number): Observable<void> {
    let url_ = this.baseUrl + "/api/Values/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: _.VitaUtil.getHeaders()
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } };
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

export class BankLogin implements IBankLogin {
  slug?: string | undefined;
  credentials?: { [key: string]: string; } | undefined;

  constructor(data?: IBankLogin) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.slug = data["slug"];
      if (data["credentials"]) {
        this.credentials = {};
        for (let key in data["credentials"]) {
          if (data["credentials"].hasOwnProperty(key))
            this.credentials[key] = data["credentials"][key];
        }
      }
    }
  }

  static fromJS(data: any): BankLogin {
    data = typeof data === 'object' ? data : {};
    let result = new BankLogin();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["slug"] = this.slug;
    if (this.credentials) {
      data["credentials"] = {};
      for (let key in this.credentials) {
        if (this.credentials.hasOwnProperty(key))
          data["credentials"][key] = this.credentials[key];
      }
    }
    return data;
  }
}

export interface IBankLogin {
  slug?: string | undefined;
  credentials?: { [key: string]: string; } | undefined;
}

export class SearchResponse implements ISearchResponse {
  id!: string;
  who?: Company | undefined;
  what?: TransactionType | undefined;
  where?: Locality | undefined;
  when?: Date | undefined;
  why?: Classifier | undefined;
  paymentMethodType?: PaymentMethodType | undefined;
  createdUtcDate!: Date;
  isChargeId!: boolean;
  chargeId?: string | undefined;

  constructor(data?: ISearchResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.who = data["who"] ? Company.fromJS(data["who"]) : <any>undefined;
      this.what = data["what"];
      this.where = data["where"] ? Locality.fromJS(data["where"]) : <any>undefined;
      this.when = data["when"] ? new Date(data["when"].toString()) : <any>undefined;
      this.why = data["why"] ? Classifier.fromJS(data["why"]) : <any>undefined;
      this.paymentMethodType = data["paymentMethodType"];
      this.createdUtcDate = data["createdUtcDate"] ? new Date(data["createdUtcDate"].toString()) : <any>undefined;
      this.isChargeId = data["isChargeId"];
      this.chargeId = data["chargeId"];
    }
  }

  static fromJS(data: any): SearchResponse {
    data = typeof data === 'object' ? data : {};
    let result = new SearchResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["who"] = this.who ? this.who.toJSON() : <any>undefined;
    data["what"] = this.what;
    data["where"] = this.where ? this.where.toJSON() : <any>undefined;
    data["when"] = this.when ? this.when.toISOString() : <any>undefined;
    data["why"] = this.why ? this.why.toJSON() : <any>undefined;
    data["paymentMethodType"] = this.paymentMethodType;
    data["createdUtcDate"] = this.createdUtcDate ? this.createdUtcDate.toISOString() : <any>undefined;
    data["isChargeId"] = this.isChargeId;
    data["chargeId"] = this.chargeId;
    return data;
  }
}

export interface ISearchResponse {
  id: string;
  who?: Company | undefined;
  what?: TransactionType | undefined;
  where?: Locality | undefined;
  when?: Date | undefined;
  why?: Classifier | undefined;
  paymentMethodType?: PaymentMethodType | undefined;
  createdUtcDate: Date;
  isChargeId: boolean;
  chargeId?: string | undefined;
}

export abstract class Tracking implements ITracking {
  createdUtc!: Date;
  modifiedUtc?: Date | undefined;

  constructor(data?: ITracking) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.createdUtc = data["createdUtc"] ? new Date(data["createdUtc"].toString()) : <any>undefined;
      this.modifiedUtc = data["modifiedUtc"] ? new Date(data["modifiedUtc"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): Tracking {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'Tracking' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["createdUtc"] = this.createdUtc ? this.createdUtc.toISOString() : <any>undefined;
    data["modifiedUtc"] = this.modifiedUtc ? this.modifiedUtc.toISOString() : <any>undefined;
    return data;
  }
}

export interface ITracking {
  createdUtc: Date;
  modifiedUtc?: Date | undefined;
}

export class Company extends Tracking implements ICompany {
  id!: string;
  companyName?: string | undefined;
  australianCompanyNumber?: string | undefined;
  companyType?: string | undefined;
  companyClass?: string | undefined;
  subClass?: string | undefined;
  status?: string | undefined;
  dateOfRegistration?: string | undefined;
  previousStateOfRegistration?: string | undefined;
  stateOfRegistrationNumber?: string | undefined;
  modifiedSinceLastReport?: string | undefined;
  currentNameIndicator?: string | undefined;
  australianBusinessNumber?: string | undefined;
  currentName?: string | undefined;
  currentNameStartDate?: string | undefined;
  companyCurrentInd?: string | undefined;
  companyCurrentName?: string | undefined;
  companyCurrentNameStartDt?: string | undefined;
  companyModifiedSinceLast?: string | undefined;

  constructor(data?: ICompany) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.id = data["id"];
      this.companyName = data["companyName"];
      this.australianCompanyNumber = data["australianCompanyNumber"];
      this.companyType = data["companyType"];
      this.companyClass = data["companyClass"];
      this.subClass = data["subClass"];
      this.status = data["status"];
      this.dateOfRegistration = data["dateOfRegistration"];
      this.previousStateOfRegistration = data["previousStateOfRegistration"];
      this.stateOfRegistrationNumber = data["stateOfRegistrationNumber"];
      this.modifiedSinceLastReport = data["modifiedSinceLastReport"];
      this.currentNameIndicator = data["currentNameIndicator"];
      this.australianBusinessNumber = data["australianBusinessNumber"];
      this.currentName = data["currentName"];
      this.currentNameStartDate = data["currentNameStartDate"];
      this.companyCurrentInd = data["companyCurrentInd"];
      this.companyCurrentName = data["companyCurrentName"];
      this.companyCurrentNameStartDt = data["companyCurrentNameStartDt"];
      this.companyModifiedSinceLast = data["companyModifiedSinceLast"];
    }
  }

  static fromJS(data: any): Company {
    data = typeof data === 'object' ? data : {};
    let result = new Company();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["companyName"] = this.companyName;
    data["australianCompanyNumber"] = this.australianCompanyNumber;
    data["companyType"] = this.companyType;
    data["companyClass"] = this.companyClass;
    data["subClass"] = this.subClass;
    data["status"] = this.status;
    data["dateOfRegistration"] = this.dateOfRegistration;
    data["previousStateOfRegistration"] = this.previousStateOfRegistration;
    data["stateOfRegistrationNumber"] = this.stateOfRegistrationNumber;
    data["modifiedSinceLastReport"] = this.modifiedSinceLastReport;
    data["currentNameIndicator"] = this.currentNameIndicator;
    data["australianBusinessNumber"] = this.australianBusinessNumber;
    data["currentName"] = this.currentName;
    data["currentNameStartDate"] = this.currentNameStartDate;
    data["companyCurrentInd"] = this.companyCurrentInd;
    data["companyCurrentName"] = this.companyCurrentName;
    data["companyCurrentNameStartDt"] = this.companyCurrentNameStartDt;
    data["companyModifiedSinceLast"] = this.companyModifiedSinceLast;
    super.toJSON(data);
    return data;
  }
}

export interface ICompany extends ITracking {
  id: string;
  companyName?: string | undefined;
  australianCompanyNumber?: string | undefined;
  companyType?: string | undefined;
  companyClass?: string | undefined;
  subClass?: string | undefined;
  status?: string | undefined;
  dateOfRegistration?: string | undefined;
  previousStateOfRegistration?: string | undefined;
  stateOfRegistrationNumber?: string | undefined;
  modifiedSinceLastReport?: string | undefined;
  currentNameIndicator?: string | undefined;
  australianBusinessNumber?: string | undefined;
  currentName?: string | undefined;
  currentNameStartDate?: string | undefined;
  companyCurrentInd?: string | undefined;
  companyCurrentName?: string | undefined;
  companyCurrentNameStartDt?: string | undefined;
  companyModifiedSinceLast?: string | undefined;
}

export enum TransactionType {
  Credit = "Credit",
  Debit = "Debit",
  Transfer = "Transfer",
  Reversal = "Reversal",
  Dishonour = "Dishonour",
  Fees = "Fees",
  Overdrawn = "Overdrawn",
  Interest = "Interest",
  Repayments = "Repayments",
  Unknown = "Unknown",
}

export class Locality extends Tracking implements ILocality {
  id!: string;
  postcode?: string | undefined;
  suburb?: string | undefined;
  australianState!: AustralianState;
  latitude!: number;
  longitude!: number;
  placeId?: string | undefined;

  constructor(data?: ILocality) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.id = data["id"];
      this.postcode = data["postcode"];
      this.suburb = data["suburb"];
      this.australianState = data["australianState"];
      this.latitude = data["latitude"];
      this.longitude = data["longitude"];
      this.placeId = data["placeId"];
    }
  }

  static fromJS(data: any): Locality {
    data = typeof data === 'object' ? data : {};
    let result = new Locality();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["postcode"] = this.postcode;
    data["suburb"] = this.suburb;
    data["australianState"] = this.australianState;
    data["latitude"] = this.latitude;
    data["longitude"] = this.longitude;
    data["placeId"] = this.placeId;
    super.toJSON(data);
    return data;
  }
}

export interface ILocality extends ITracking {
  id: string;
  postcode?: string | undefined;
  suburb?: string | undefined;
  australianState: AustralianState;
  latitude: number;
  longitude: number;
  placeId?: string | undefined;
}

export enum AustralianState {
  ACT = 0,
  NSW = 1,
  NT = 2,
  QLD = 3,
  SA = 4,
  TAS = 5,
  VIC = 6,
  WA = 7,
}

export class Classifier implements IClassifier {
  id!: string;
  categoryType!: CategoryType;
  subCategory?: string | undefined;
  keywords?: string[] | undefined;

  constructor(data?: IClassifier) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(data?: any) {
    if (data) {
      this.id = data["id"];
      this.categoryType = data["categoryType"];
      this.subCategory = data["subCategory"];
      if (data["keywords"] && data["keywords"].constructor === Array) {
        this.keywords = [];
        for (let item of data["keywords"])
          this.keywords.push(item);
      }
    }
  }

  static fromJS(data: any): Classifier {
    data = typeof data === 'object' ? data : {};
    let result = new Classifier();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["categoryType"] = this.categoryType;
    data["subCategory"] = this.subCategory;
    if (this.keywords && this.keywords.constructor === Array) {
      data["keywords"] = [];
      for (let item of this.keywords)
        data["keywords"].push(item);
    }
    return data;
  }
}

export interface IClassifier {
  id: string;
  categoryType: CategoryType;
  subCategory?: string | undefined;
  keywords?: string[] | undefined;
}

export enum CategoryType {
  BankingFinance = 0,
  Entertainment = 1,
  FoodDrinks = 2,
  Groceries = 3,
  HealthBeauty = 4,
  HolidayTravel = 5,
  Home = 6,
  HouseholdUtilities = 7,
  Income = 8,
  Insurance = 9,
  Kids = 10,
  Miscellaneous = 11,
  Shopping = 12,
  TransferringMoney = 13,
  Transport = 14,
  Uncategorised = 15,
  WorkStudy = 16,
}

export enum PaymentMethodType {
  CashWithdrawl = "CashWithdrawl",
  Eftpos = "Eftpos",
  DirectDebit = "DirectDebit",
  CreditCard = "CreditCard",
  Unknown = "Unknown",
}

export class Charge extends Tracking implements ICharge {
  id!: string;
  searchPhrase?: string | undefined;
  keywords?: string | undefined;
  notes?: string | undefined;
  transactionDate?: Date | undefined;
  postedDate?: Date | undefined;
  companyId?: string | undefined;
  bankCode?: string | undefined;
  bankName?: string | undefined;
  bsb?: string | undefined;
  accountNumber?: string | undefined;
  accountName?: string | undefined;
  balance?: number | undefined;
  balanceAvailable?: number | undefined;
  transactionType?: TransactionType | undefined;
  expenseType!: ExpenseType;
  localityId?: string | undefined;
  placeId?: string | undefined;
  category!: CategoryType2;
  subCategory?: string | undefined;
  placeLocationType?: PlaceLocationType[] | undefined;
  paymentMethod!: PaymentMethodType;
  jsonData?: { [key: string]: string; } | undefined;

  constructor(data?: ICharge) {
    super(data);
  }

  init(data?: any) {
    super.init(data);
    if (data) {
      this.id = data["id"];
      this.searchPhrase = data["searchPhrase"];
      this.keywords = data["keywords"];
      this.notes = data["notes"];
      this.transactionDate = data["transactionDate"] ? new Date(data["transactionDate"].toString()) : <any>undefined;
      this.postedDate = data["postedDate"] ? new Date(data["postedDate"].toString()) : <any>undefined;
      this.companyId = data["companyId"];
      this.bankCode = data["bankCode"];
      this.bankName = data["bankName"];
      this.bsb = data["bsb"];
      this.accountNumber = data["accountNumber"];
      this.accountName = data["accountName"];
      this.balance = data["balance"];
      this.balanceAvailable = data["balanceAvailable"];
      this.transactionType = data["transactionType"];
      this.expenseType = data["expenseType"];
      this.localityId = data["localityId"];
      this.placeId = data["placeId"];
      this.category = data["category"];
      this.subCategory = data["subCategory"];
      if (data["placeLocationType"] && data["placeLocationType"].constructor === Array) {
        this.placeLocationType = [];
        for (let item of data["placeLocationType"])
          this.placeLocationType.push(item);
      }
      this.paymentMethod = data["paymentMethod"];
      if (data["jsonData"]) {
        this.jsonData = {};
        for (let key in data["jsonData"]) {
          if (data["jsonData"].hasOwnProperty(key))
            this.jsonData[key] = data["jsonData"][key];
        }
      }
    }
  }

  static fromJS(data: any): Charge {
    data = typeof data === 'object' ? data : {};
    let result = new Charge();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["searchPhrase"] = this.searchPhrase;
    data["keywords"] = this.keywords;
    data["notes"] = this.notes;
    data["transactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
    data["postedDate"] = this.postedDate ? this.postedDate.toISOString() : <any>undefined;
    data["companyId"] = this.companyId;
    data["bankCode"] = this.bankCode;
    data["bankName"] = this.bankName;
    data["bsb"] = this.bsb;
    data["accountNumber"] = this.accountNumber;
    data["accountName"] = this.accountName;
    data["balance"] = this.balance;
    data["balanceAvailable"] = this.balanceAvailable;
    data["transactionType"] = this.transactionType;
    data["expenseType"] = this.expenseType;
    data["localityId"] = this.localityId;
    data["placeId"] = this.placeId;
    data["category"] = this.category;
    data["subCategory"] = this.subCategory;
    if (this.placeLocationType && this.placeLocationType.constructor === Array) {
      data["placeLocationType"] = [];
      for (let item of this.placeLocationType)
        data["placeLocationType"].push(item);
    }
    data["paymentMethod"] = this.paymentMethod;
    if (this.jsonData) {
      data["jsonData"] = {};
      for (let key in this.jsonData) {
        if (this.jsonData.hasOwnProperty(key))
          data["jsonData"][key] = this.jsonData[key];
      }
    }
    super.toJSON(data);
    return data;
  }
}

export interface ICharge extends ITracking {
  id: string;
  searchPhrase?: string | undefined;
  keywords?: string | undefined;
  notes?: string | undefined;
  transactionDate?: Date | undefined;
  postedDate?: Date | undefined;
  companyId?: string | undefined;
  bankCode?: string | undefined;
  bankName?: string | undefined;
  bsb?: string | undefined;
  accountNumber?: string | undefined;
  accountName?: string | undefined;
  balance?: number | undefined;
  balanceAvailable?: number | undefined;
  transactionType?: TransactionType | undefined;
  expenseType: ExpenseType;
  localityId?: string | undefined;
  placeId?: string | undefined;
  category: CategoryType2;
  subCategory?: string | undefined;
  placeLocationType?: PlaceLocationType[] | undefined;
  paymentMethod: PaymentMethodType;
  jsonData?: { [key: string]: string; } | undefined;
}

export enum ExpenseType {
  None = "None",
  PersonalLoan = "PersonalLoan",
  CarLoan = "CarLoan",
  PaydayLoan = "PaydayLoan",
  ChildCare = "ChildCare",
  ChildSupport = "ChildSupport",
  DebtAgreement = "DebtAgreement",
  Foxtel = "Foxtel",
  GymMembership = "GymMembership",
  Insurances = "Insurances",
  PenaltyOrFinePayments = "PenaltyOrFinePayments",
  OtherExpenses = "OtherExpenses",
  Living = "Living",
}

export enum CategoryType2 {
  BankingFinance = "BankingFinance",
  Entertainment = "Entertainment",
  FoodDrinks = "FoodDrinks",
  Groceries = "Groceries",
  HealthBeauty = "HealthBeauty",
  HolidayTravel = "HolidayTravel",
  Home = "Home",
  HouseholdUtilities = "HouseholdUtilities",
  Income = "Income",
  Insurance = "Insurance",
  Kids = "Kids",
  Miscellaneous = "Miscellaneous",
  Shopping = "Shopping",
  TransferringMoney = "TransferringMoney",
  Transport = "Transport",
  Uncategorised = "Uncategorised",
  WorkStudy = "WorkStudy",
}

/** Place Location Types https://developers.google.com/places/supported_types#table1 https://developers.google.com/places/supported_types#table2 */
export enum PlaceLocationType {
  Uknown = 0,
  Geocode = 1,
  Street_Address = 2,
  Route = 3,
  Intersection = 4,
  Political = 5,
  Country = 6,
  Administrative_Area_Level_1 = 7,
  Administrative_Area_Level_2 = 8,
  Administrative_Area_Level_3 = 9,
  Administrative_Area_Level_4 = 10,
  Administrative_Area_Level_5 = 11,
  Colloquial_Area = 12,
  Locality = 13,
  Sublocality = 14,
  Sublocality_Level_1 = 15,
  Sublocality_Level_2 = 16,
  Sublocality_Level_3 = 17,
  Sublocality_Level_4 = 18,
  Sublocality_Level_5 = 19,
  Neighborhood = 20,
  Premise = 21,
  Subpremise = 22,
  Postal_Code = 23,
  Postal_Code_Prefix = 24,
  Postal_Code_Suffix = 25,
  Natural_Feature = 26,
  Point_Of_Interest = 27,
  Floor = 28,
  Post_Box = 29,
  Postal_Town = 30,
  Room = 31,
  Street_Number = 32,
  Transit_Station = 33,
  Accounting = 34,
  Airport = 35,
  Amusement_Park = 36,
  Aquarium = 37,
  Art_Gallery = 38,
  Atm = 39,
  Bakery = 40,
  Bank = 41,
  Bar = 42,
  Beauty_Salon = 43,
  Bicycle_Store = 44,
  Book_Store = 45,
  Bowling_Alley = 46,
  Bus_Station = 47,
  Cafe = 48,
  Campground = 49,
  Car_Dealer = 50,
  Car_Rental = 51,
  Car_Repair = 52,
  Car_Wash = 53,
  Casino = 54,
  Cemetery = 55,
  Church = 56,
  City_Hall = 57,
  Clothing_Store = 58,
  Convenience_Store = 59,
  Courthouse = 60,
  Dentist = 61,
  Department_Store = 62,
  Doctor = 63,
  Electrician = 64,
  Electronics_Store = 65,
  Embassy = 66,
  Establishment = 67,
  Finance = 68,
  Fire_Station = 69,
  Florist = 70,
  Food = 71,
  Funeral_Home = 72,
  Furniture_Store = 73,
  Gas_Station = 74,
  General_Contractor = 75,
  Supermarket = 76,
  Grocery_Or_Supermarket = 77,
  Gym = 78,
  Hair_Care = 79,
  Hardware_Store = 80,
  Health = 81,
  Hindu_Temple = 82,
  Home_Goods_Store = 83,
  Hospital = 84,
  Insurance_Agency = 85,
  Jewelry_Store = 86,
  Laundry = 87,
  Lawyer = 88,
  Library = 89,
  Liquor_Store = 90,
  Local_Government_Office = 91,
  Locksmith = 92,
  Lodging = 93,
  Meal_Delivery = 94,
  Meal_Takeaway = 95,
  Mosque = 96,
  Movie_Rental = 97,
  Movie_Theater = 98,
  Moving_Company = 99,
  Museum = 100,
  Night_Club = 101,
  Painter = 102,
  Park = 103,
  Parking = 104,
  Pet_Store = 105,
  Pharmacy = 106,
  Physiotherapist = 107,
  Place_Of_Worship = 108,
  Plumber = 109,
  Police = 110,
  PostOffice = 111,
  Real_Estate_Agency = 112,
  Restaurant = 113,
  Roofing_Contractor = 114,
  Rv_Park = 115,
  School = 116,
  Shoe_Store = 117,
  Shopping_Mall = 118,
  Spa = 119,
  Stadium = 120,
  Storage = 121,
  Store = 122,
  Subway_Station = 123,
  Synagogue = 124,
  Taxi_Stand = 125,
  Train_Station = 126,
  Travel_Agency = 127,
  University = 128,
  Veterinary_Care = 129,
  Zoo = 130,
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  return _observableThrow(new SwaggerException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = function () {
        observer.next(this.result);
        observer.complete();
      }
      reader.readAsText(blob);
    }
  });
}